# Sofia Memory Plugin

Sofia Memory Plugin \u2014 это небольшой сервис на Node.js, предоставляющий REST API для работы с файлами памяти и планами обучения. В репозитории хранится пример структуры памяти, набор утилит для обработки Markdown и тесты.

## Быстрый старт

1. Установите зависимости:
   ```bash
   npm install
   ```
2. Запустите сервер:
   ```bash
   npm start
   ```
   По умолчанию приложение слушает порт `10000`.
   Логи сервера сохраняют ответы GitHub (код и сообщение), что облегчает
   поиск причин ошибок при работе с репозиторием.

Для конфигурации можно использовать файл `.env` (см. `.env.example`) или `config/config.json`, где задаются URL репозиториев и токены доступа. Переменная `TOKEN_SECRET` позволяет задать ключ для шифрования сохранённых токенов.

## Запуск тестов

Все unit-тесты запускаются командой:
```bash
npm test
```

## Основные эндпойнты

Полное описание находится в файле `openapi.yaml` и доступно через `GET /docs` после запуска сервера. Ниже перечислены ключевые маршруты:

- `POST /save` \u2014 сохранить файл в репозитории;
- `POST /read` \u2014 прочитать содержимое файла;
- `POST /saveMemory` и `POST /readMemory` \u2014 работа с основной памятью;
- При сохранении через `POST /saveMemory` перед записью проверяется GitHub токен
  и существование репозитория. Неверный токен приводит к ответу `401`,
  отсутствующий репозиторий — к `404`. В этих случаях запись в GitHub не
  выполняется;
- `POST /saveMemoryWithIndex` \u2014 сохранить файл и обновить `index.json`;
- `POST /saveAnswer` \u2014 сохранить эталонный ответ;
- `POST /saveLessonPlan` \u2014 обновить план обучения;
- `POST /loadMemoryToContext` \u2014 загрузить указанный файл в текущий контекст;
- `POST /setMemoryRepo` \u2014 задать репозиторий пользователя;
- `POST /version/commit` и `POST /version/rollback` \u2014 управление версиями инструкций;
- `GET /profile` \u2014 получить сохраненный профиль;
- `GET /ping` \u2014 проверка работоспособности.

## Кодстайл

В проекте допустимы три стиля именования:

- `snake_case`;
- `UPPER_SNAKE_CASE`;
- `И_Мой_Стиль`.

Использование camelCase и других вариантов не приветствуется. Перед коммитом убедитесь, что новые файлы и функции соответствуют одному из указанных стилей.

## Работа с `index.json`

Утилиты из `logic/index_manager.js` помогают поддерживать актуальный список уроков и других файлов. Основные функции:

- `validateFilePathAgainstIndex(path)` \u2014 сверяет путь с данными из индекса и подсказывает корректное расположение файла;
- `getLessonPath(num)` \u2014 возвращает путь урока по номеру, создавая запись вида `memory/lessons/lesson_XX.md`, если ее еще нет.
- Дополнительно доступны методы `getLessonByNumber`, `getByPath`, `getByTag`, `getNextLesson` и `updateMetadata` для работы с расширенным `index.json`.

Формат `index.json` теперь поддерживает категории:
```json
{
  "lessons": {
    "05": { "title": "Box Model", "path": "memory/lessons/05_box_model.md" }
  },
  "plans": { ... },
  "checklists": { ... }
}
```

Эти функции упрощают добавление новых материалов и предотвращают появление дубликатов.

### Новые возможности

- Индекс автоматически сортируется по полю `priority`: сначала `high`, затем `medium`, затем `low`.
- Добавлены функции фильтрации: `filterByStatus`, `filterByTags`, `filterByDate`, `filterByCategory`.
- Для поиска по ключевым словам используйте `searchByKeyword`.
- `getContextFilesForKeywords` помогает подобрать файлы для восстановления контекста на основе темы диалога.
- Вызов `sortIndexByPriority()` принудительно перестраивает порядок записей в `index.json`.
- При старте сервера автоматически считываются файлы с `context_priority: high` и формируется базовый контекст. Команда `Восстанови контекст из <file>` загружает указанный файл вручную.
- Файл `memory/context/autocontext-index.md` задаёт список важных документов. Если в нём указан `context_priority: high`, файлы из раздела `files` будут загружены автоматически при запуске. Команда `Восстанови контекст из autocontext-index.md` позволяет выполнить эту операцию вручную.
- `checkAndRestoreContext(stage, tokens)` следит за лимитом токенов и восстанавливает контекст после завершения теории или практики.
- `getTokenCounter()` возвращает текущее количество токенов и лимит, а `formatTokenCounter(true)` выводит строку вида `[Тестирование] Токенов использовано: 1200/3000 (40%) | Осталось: 1800`.


### Миграция устаревших файлов памяти

Новая утилита `tools/memory_migrator.js` помогает обнаружить файлы старого формата и привести их к актуальной схеме. Функции API:

- `migrateMemoryFile(path)` \u2014 конвертирует указанный Markdown-файл, добавляя фронтматтер и якоря;
- `migrateAllLegacyFiles(dir)` \u2014 рекурсивно обрабатывает каталог с памятью.

После миграции добавляется поле `migrated: true`, файл помещается в индекс и получает версию `1.2`.

### Система проверки индекса

Модуль `logic/index_validator.js` обеспечивает контроль целостности `index.json`.
При загрузке индекса все записи проверяются:

- путь должен находиться внутри каталога `memory/`;
- наличие файла подтверждается через `fs.existsSync`;
- ссылки на файлы плагина игнорируются.

Неверные записи автоматически удаляются (если не указано `pinned: true`),
отсутствующие файлы отмечаются в отчёте проверки. Параметры поведения задаются в
`indexSettings` и включают очистку отсутствующих файлов и блокировку путей
плагина.

### Многоуровневая структура `index.json`

Фолдер `memory/multi_index` содержит экспериментальную схему индекса, где главный `index.json` хранит ссылки на подчинённые индексы и их метаданные. Пример корневого файла:

```json
{
  "lessons": {
    "index": "multi_index/lessons/index.json",
    "metadata": { "sort_order": 1, "search_priority": "high" }
  }
}
```

В дочерних индексах элементы имеют блок `metadata` с полями `sort_order`, `search_priority`, `category` и `sub_category`. Поиск через `searchInIndex(query, indexFile)` отдаёт максимум десять совпадений из каждого файла индекса.

